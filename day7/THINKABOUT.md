# THINKABOUT Day 7

## [메타인지 체크] 🤔

스스로에게 질문하며 개념을 더 깊이 이해해 봅시다.

### 💭 설계 선택에 대한 이해

**Q1: `try_add`가 `bool`을 반환하도록 설계한 이유는 무엇일까요?**

다음 관점에서 생각해 보세요:
- `Result<(), Error>` 대신 `bool`을 선택한 이유는?
- 호출하는 쪽에서 어떤 정보가 필요할까?
- 더 복잡한 반환 타입이 필요한 경우는 언제일까?

<details>
<summary>💡 힌트 보기</summary>

`bool`은 "성공/실패"만 구분하면 충분한 단순한 상황에 적합합니다. 만약 "왜 실패했는지"(컴퓨트 초과인지, 트랜잭션 수 초과인지)를 구분해야 한다면 `Result<(), AddError>`가 더 적합할 것입니다.

</details>

---

**Q2: 잔여 용량을 계산할 때 어떤 순서로 변수를 업데이트하면 실수를 줄일 수 있을까요?**

고려할 점:
- 합계를 먼저 업데이트하고 `push`할까, 아니면 반대로?
- 만약 중간에 오류가 발생하면 어떻게 될까?
- 원자적(atomic) 업데이트란 무엇일까?

<details>
<summary>💡 힌트 보기</summary>

"검증 → 합계 업데이트 → push" 순서가 안전합니다. 검증에 실패하면 아무것도 변경되지 않고, 검증이 통과하면 합계와 벡터가 일관되게 업데이트됩니다.

</details>

---

### 🧪 테스트 전략에 대한 고찰

**Q3: 테스트를 작성할 때 "성공 케이스"와 "제한을 넘는 케이스" 중 어떤 것을 먼저 다루는 것이 더 편했나요?**

생각해 볼 점:
- TDD(테스트 주도 개발)에서는 어떤 순서를 권장할까?
- 실패 케이스를 먼저 작성하면 어떤 장단점이 있을까?
- 복잡한 시스템에서는 어떤 전략이 효과적일까?

<details>
<summary>💡 힌트 보기</summary>

일반적으로 "성공 케이스(happy path)"를 먼저 작성하면 기본 로직이 동작하는지 빠르게 검증할 수 있습니다. 그 후 엣지 케이스와 실패 시나리오를 추가하면 코드가 더 견고해집니다.

</details>

---

### 🔄 자료구조 선택에 대한 고민

**Q4: `BinaryHeap`으로 정렬된 결과를 그대로 사용할 때와 `Vec`으로 변환한 뒤 사용하는 것 사이에는 어떤 장단점이 있을까요?**

비교 관점:
- 메모리 사용량은?
- 처리 속도는?
- 코드 가독성은?
- 유연성은? (예: 중간에 순서를 바꾸고 싶다면?)

<details>
<summary>💡 힌트 보기</summary>

**BinaryHeap 직접 사용:**
- 장점: 메모리 효율적 (필요한 만큼만 pop)
- 단점: 중간에 접근하거나 순회하기 어려움

**Vec 변환 후 사용:**
- 장점: 인덱스 접근, 순회, 슬라이싱 등 유연함
- 단점: 모든 항목을 한 번에 변환해야 함 (메모리 증가)

오늘 과제에서는 모든 항목을 순차 처리하므로 Vec 변환이 적합합니다.

</details>

---

## [직접 리서치해 볼 문제] 🔍

스스로 답을 찾아보며 지식을 확장해 봅시다.

### 🌐 실전 Solana 지식

**R1: Solana에서 컴퓨트 유닛 한도를 넘으면 어떤 에러가 발생하는지 공식 문서를 찾아보세요.**

검색 힌트:
- `solana compute budget exceeded error` 검색
- Solana 공식 문서의 "Transaction" 섹션 확인
- 실제 에러 코드나 메시지는 무엇인가요?

질문:
1. 에러가 발생하는 시점은? (트랜잭션 제출 시? 실행 시?)
2. 사용자가 컴퓨트 한도를 늘리는 방법이 있나요?
3. 기본 컴퓨트 한도는 얼마인가요?

---

### 🧩 Rust 고급 기능 활용

**R2: `IntoIterator` 트레이트를 사용하면 `try_add`를 반복 호출하는 보조 함수를 어떻게 만들 수 있을까요?**

시작점:
```rust
impl SlotPlanner {
    pub fn try_add_many<I>(&mut self, entries: I) -> usize
    where
        I: IntoIterator<Item = MempoolEntry>,
    {
        // 여기에 구현...
        // 힌트: 성공한 개수를 반환하면 유용합니다
    }
}
```

고민해 볼 점:
- `IntoIterator`를 사용하면 어떤 타입들을 입력으로 받을 수 있나요?
- `Vec`, 슬라이스 `&[MempoolEntry]`, `BinaryHeap` 모두 작동할까요?
- 실패한 항목들을 따로 수집하려면 어떻게 해야 할까요?

---

### 🔄 알고리즘 변형

**R3: 제한을 넘기는 항목을 "건너뛰지 말고 대체하는" 전략을 구현하려면 어떤 추가 데이터가 필요할까요?**

시나리오:
```
현재 번들: [트랜잭션A: 500CU, 수수료 1000]
새 항목: [트랜잭션B: 300CU, 수수료 2000]
제한: 500CU

그리디: B를 거부 (제한 초과)
대체 전략: A를 제거하고 B를 추가? (더 높은 수수료)
```

질문:
1. 어떤 경우에 대체가 이득일까요?
2. 대체를 판단하는 기준은?
3. 여러 개를 대체해야 한다면? (배낭 문제와 유사)
4. 추가로 저장해야 할 정보는?

---

### 🎯 우선순위 변경

**R4: 수수료 기준 대신 다른 우선순위(예: compute 단위가 적은 순)를 적용하려면 `BinaryHeap` 비교 로직을 어떻게 바꿔야 할까요?**

도전 과제:
```rust
// 수수료가 아닌 컴퓨트 유닛 기준으로 정렬하려면?
impl Ord for MempoolEntry {
    fn cmp(&self, other: &Self) -> Ordering {
        // 어떻게 수정해야 할까요?
        // 힌트: 컴퓨트가 "작을수록" 우선순위가 높다면?
    }
}
```

고민 포인트:
1. 최소 힙(min-heap)을 만들려면 비교 순서를 어떻게 바꿔야 할까요?
2. "수수료 대 컴퓨트 비율"로 정렬하려면?
3. 여러 기준을 조합하려면? (예: 수수료가 같으면 컴퓨트가 작은 것 우선)

---

## [심화 질문] 🚀

### 💡 확장 가능성

**Q5: 현재 구조에서 "계정 잠금(account locks)" 개념을 추가하려면 어떻게 설계해야 할까요?**

배경:
- Solana에서는 여러 트랜잭션이 같은 계정을 동시에 수정할 수 없습니다.
- 같은 계정을 쓰는 트랜잭션은 순차적으로 처리해야 합니다.

질문:
1. `MempoolEntry`에 어떤 필드를 추가해야 할까요?
2. `try_add`에서 어떤 추가 검증이 필요할까요?
3. 성능을 위해 어떤 자료구조를 사용하면 좋을까요? (HashMap?)

---

### 📊 성능 분석

**Q6: 1만 개의 트랜잭션을 처리할 때 병목(bottleneck)이 발생하는 부분은 어디일까요?**

분석 관점:
1. `BinaryHeap::push` - O(log n)
2. `BinaryHeap::pop` - O(log n)
3. `try_add` - O(1)
4. 전체 시간 복잡도는?

실험:
```rust
use std::time::Instant;

let start = Instant::now();
// 작업 수행
let duration = start.elapsed();
println!("처리 시간: {:?}", duration);
```

- 직접 벤치마크를 작성해 보고 결과를 측정해 보세요!

---

## [자기 평가 체크리스트] ✅

다음 질문들에 자신 있게 답할 수 있나요?

- [ ] 그리디 알고리즘이 무엇인지 다른 사람에게 설명할 수 있다
- [ ] `BinaryHeap`과 `Vec`의 차이를 성능 관점에서 설명할 수 있다
- [ ] `saturating_sub`가 왜 필요한지 실제 예시와 함께 설명할 수 있다
- [ ] `try_add`가 `false`를 반환하는 상황을 3가지 이상 말할 수 있다
- [ ] 테스트 케이스를 추가로 2개 이상 생각해낼 수 있다
- [ ] 실제 Solana에서 이 개념이 어떻게 사용되는지 이해했다

모두 체크했다면 Day 7을 완벽히 이해한 것입니다! 🎉