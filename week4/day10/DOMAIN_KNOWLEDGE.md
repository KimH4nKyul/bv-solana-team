# 도메인 지식: 헤더 포크 선택기 완전 정복 (파인만 설명 방식)

이 문서는 Day 10 과제인 `HeaderForkChoice`를 구현할 때 꼭 알아야 할 동작 원리를 설명합니다. "누가봐도 이해되는" 설명을 목표로 하되, Reth가 실제로 사용하는 포크 선택기의 핵심 디테일은 빠짐없이 담았습니다.

---

## 1. 한눈에 보는 포크 선택기의 역할

Ethereum 노드는 매초 여러 피어(peer)에게서 새로운 블록 헤더를 받습니다. 때로는 **동시에 두 개 이상의 헤더**가 들어오는데, 어떤 헤더가 진짜 체인인지 즉시 알 수 없습니다. 그때 포크 선택기가 등장합니다.

- **문제**: 서로 다른 헤더가 같은 높이를 주장하거나, 더 오래된 헤더의 자식이 뒤늦게 도착할 수 있음.
- **해결 전략**: 각 헤더가 가진 `total difficulty`(현재까지 누적된 작업량)를 비교해 **가장 무거운 체인**을 canonical로 채택.
- **핵심 아이디어**: 헤더를 트리(혹은 그래프)로 모아두고, 새 헤더가 도착할 때마다 누적 난이도를 갱신하고 비교한다.

> **비유: 등산 기록 앱**
> - 여러 친구가 같은 산을 다른 코스로 오르고 있다고 상상해 봅시다.
> - 앱은 각 코스(체인)의 총 고도 상승량(total difficulty)을 기록합니다.
> - 가장 높은 고도 상승량을 기록한 코스가 “정상까지 성공한 공식 코스(canonical chain)”로 표시됩니다.

포크 선택기는 이 간단한 규칙을 코드로 옮겨, 네트워크가 일시적으로 충돌을 겪더라도 **일관된 체인 한 줄기를 유지**하게 만듭니다.

---

## 2. 등장인물 소개: 우리가 저장하는 데이터들

Day 10 구조체들은 실제 Reth가 사용하는 테이블을 소형화한 버전입니다. 각 필드가 *왜* 필요한지 이해해야 구현과 디버깅이 쉬워집니다.

| 타입/필드                         | 설명                                                                                     | 왜 중요한가?                                                                                           |
|----------------------------------|------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|
| `BlockHeader`                    | 번호, 해시, 부모 해시, 난이도 등을 지닌 헤더의 최소 표현                                | 네트워크에서 받은 원본 입력. 모든 판단의 시작점.                                                        |
| `StoredHeader`                   | `header`, `parent`, `total_difficulty`를 묶은 래퍼                                       | parent 해시를 캐시해 역추적을 빠르게 하고, 누적 난이도를 계속 참조할 수 있게 해 준다.                 |
| `HeaderForkChoice::nodes`        | `HashMap<String, StoredHeader>`                                                          | 해시 → 헤더 노드를 O(1)에 조회. 부모 탐색과 누적 난이도 비교의 기반.                                  |
| `HeaderForkChoice::canonical`    | `Vec<String>`                                                                            | 현재 채택된 canonical 경로의 해시 열. index가 블록 번호와 자연스럽게 대응된다.                       |
| `HeaderForkChoice::genesis_hash` | 제네시스 헤더 해시                                                                       | canonical 재구성 시 “여기까지는 확정”이라는 기준점.                                                   |
| `ReorgOutcome`                   | 포크 삽입 결과를 외부 Stage에 알리는 enum                                               | 실행 Stage는 결과에 따라 “새 블록 실행” vs “롤백 후 재실행”을 결정하므로, 명확한 신호가 필수.        |
| `HeaderInsertError`              | 삽입 중 발견된 오류를 상세하게 보고                                                      | 조기에 실패 원인을 파악하고 상위 모듈이 재시도/포기 판단을 즉시 내릴 수 있다.                        |

---

## 3. total difficulty: “누적 점수”를 비교하는 이유

`total difficulty`는 부모 체인의 누적 난이도에 현재 헤더의 `difficulty`를 더한 값입니다. PoW에서는 곧바로 **들어간 작업량의 총합**이라고 생각해도 무방합니다.

- 같은 높이의 두 헤더가 경쟁할 때, total difficulty가 더 큰 쪽이 더 많은 에너지를 들여 만들어진 체인이라는 뜻입니다.
- 네트워크 지연 때문에 뒤늦게 더 무거운 체인이 도착하면, 기존 canonical을 버리고 새 체인으로 **재구성(reorg)** 해야 합니다.
- Reth는 PoS로 전환한 이후에도 내부적으로는 유사한 개념(최종화 체크포인트의 weight 등)을 추상화 레이어에서 다루지만, 이 과제에서는 PoW total difficulty 모델을 그대로 사용합니다.

**계산 공식**  
```text
new_total = parent.total_difficulty + header.difficulty as u128
```
- parent를 정확히 찾아야만 누적 값이 맞게 이어집니다.
- `difficulty`가 `u64`라 하더라도, 누적 값은 매우 커지므로 `u128` 같은 넉넉한 타입을 사용합니다.

---

## 4. PoS 시대의 포크 선택은 어떻게 달라졌나?

The Merge 이후 Ethereum은 작업증명 대신 **비콘 체인 기반의 지분증명(PoS)** 합의를 사용합니다. 이 시점부터 실행 레이어 헤더의 `difficulty` 필드는 0으로 고정되고, `total difficulty`는 역사적인 기록이나 TTD 체크(머지 시점 확인)에만 쓰입니다. 포크 선택 판단은 전적으로 **컨센서스 레이어(CL)**의 책임이 되었습니다.

- 컨센서스 레이어는 LMD-GHOST + Casper FFG 조합을 이용해 **검증인 투표(weight)**를 모읍니다. 해시 파워 대신 활성 검증인들의 지분이 체인의 “무게”를 결정합니다.
- CL은 주기적으로 실행 클라이언트(예: Reth)에게 `forkchoiceUpdated` 요청을 보내 **Head/Justified/Finalized 체크포인트**를 전달합니다. 실행 클라이언트는 전달받은 헤더를 기준으로 상태 전이를 수행할 뿐, 자체적으로 체인의 우열을 가리지는 않습니다.
- PoW 시절의 `NewPayload`는 “더 무거운 체인을 발견했다”는 의미였지만, PoS에서는 “검증인 투표로 선택된 최신 실행 페이로드”를 검증하라는 신호입니다.
- PoS에서도 reorg가 발생할 수 있지만, **최종화(finalization)** 덕분에 깊이가 크게 제한됩니다. Finalized 체크포인트는 되돌릴 수 없으므로, 실행 클라이언트는 그 이전 상태를 건드리지 않습니다.

| 구분                         | PoW 시절                                               | PoS 이후 (The Merge 이후)                              |
|------------------------------|--------------------------------------------------------|--------------------------------------------------------|
| 체인 “무게” 판단 기준        | 누적 작업량(`total difficulty`)                         | 검증인 투표 가중치(LMD-GHOST)                          |
| 포크 선택 책임               | 실행 클라이언트 자체 판단                              | 컨센서스 클라이언트가 결정, 실행 클라이언트는 수신/검증 |
| 롤백 가능 깊이               | 해시 파워에 따라 제약 없음                             | Finality 덕분에 수십 슬롯 이내로 강하게 제한          |
| `difficulty` / `total_difficulty` 필드 | 실시간으로 업데이트                                    | 0/정적 값. 보존은 되지만 실제 결정에는 사용되지 않음   |

> **과제와의 연결고리**  
> Day 10 과제는 PoW 스타일 포크 선택기를 구현하며 개념을 익히도록 설계되었습니다. 실제 Reth 코드베이스에서도 테스트, PoW 체인 호환성, 사내 시뮬레이션 등을 위해 이 로직이 유지됩니다. PoS 현실 세계를 이해하되, 오늘 과제에서는 PoW 모델로 사고 실험을 하는 것이라 생각하면 편합니다.

---

## 5. 그래프 탐색으로 canonical 재구성하기

새 헤더가 들어오면 우리는 다음 질문을 순서대로 던집니다.

1. **이 해시를 이미 본 적 있는가?**  
   → 있다면 중복삽입 오류(`DuplicateHash`). 같은 해시는 같은 노드를 의미하므로 두 번 처리할 필요가 없습니다.

2. **부모는 존재하는가?**  
   → 없다면 `UnknownParent`. 헤더 동기화 순서가 꼬인 상태니, 나중을 기약하며 저장을 거절해야 합니다.

3. **부모 번호 + 1 규칙을 지키는가?**  
   → 아니면 `NumberMismatch`. 공격자가 만든 엉뚱한 헤더일 수 있고, 체인 구조를 깨뜨립니다.

4. **누적 난이도는 얼마나 되는가?**  
   → 현재 canonical head보다 커야 canonical 교체 후보가 됩니다.

reorg가 필요한지 판단하는 핵심은 `rebuild_canonical_if_needed` 흐름입니다.

```text
1) 현재 canonical head의 total difficulty를 가져온다.
2) 새 헤더의 total difficulty가 더 크지 않으면 canonical은 그대로 둔다.
3) 더 크다면, 새 헤더에서 시작해 parent 링크를 타고 genesis까지 역추적한다.
4) 역순으로 쌓인 경로를 뒤집으면 “새 canonical 후보”가 된다.
5) 기존 canonical과 공통 prefix를 비교해 reorg 깊이를 구한다.
6) canonical을 새 경로로 통째로 교체하고, 결과(enum)를 만들어 반환한다.
```

> **Tip**: 공통 prefix는 곧 “롤백하지 않아도 되는 안정 구간”입니다. prefix 길이 이후의 블록만 롤백하면 되므로, 실행 Stage에 “얼마를 되감아야 하는지” 전달할 수 있습니다.

---

## 6. ReorgOutcome으로 외부 Stage와 대화하기

포크 선택기는 단순히 데이터를 바꾸는 데 그치지 않고, 이후 Stage(예: Execution)에게 **다음 행동을 지시**해야 합니다.

- `NoReorg`: canonical이 그대로이므로 상위 Stage가 아무 것도 할 필요가 없습니다.
- `Extended { new_head }`: 기존 canonical head의 자식이 붙었습니다. 실행 Stage는 새 블록을 순서대로 실행하면 됩니다.
- `Reorganized { new_head, old_head, depth }`: 더 무거운 다른 포크로 갈아탔습니다. 상위 Stage는 `depth`만큼 롤백한 뒤, 새 canonical의 헤더들을 재실행해야 합니다.

이 명확한 신호 덕분에 Stage 간 결합도가 낮고, 재사용성이 높아집니다. (Reth도 거의 동일한 결과 타입을 사용합니다.)

---

## 7. 에러 핸들링은 방어선이다

`HeaderInsertError`는 곧 “포크 선택기가 지켜야 할 규칙” 목록입니다.

- `DuplicateHash { hash }`: 네트워크에서 동일 헤더가 중복 전달될 수 있으므로 반드시 차단해야 합니다.
- `UnknownParent { parent_hash }`: parent가 아직 DB에 없을 때는 헤더를 큐에 쌓거나 버퍼에 넣어야 합니다. Day 10에선 실패로 처리합니다.
- `NumberMismatch { expected, got }`: 헤더 번호는 체인의 “자연 번호”이므로 하나라도 빗나가면 전체 정합성이 무너집니다.

이 에러들을 빠르게 반환하면 상위 모듈이 재시도 여부, 피어 차단, 추가 데이터 요청을 결정할 수 있습니다.

---

## 8. 현실 시나리오로 살펴본 reorg

다음은 실제로 발생할 수 있는 상황을 단순화한 예시입니다.

| 시점 | 도착 헤더 | 설명                                                                            | canonical 결과                     |
|------|-----------|---------------------------------------------------------------------------------|------------------------------------|
| t₀   | `A1`      | 제네시스 `A0`의 자식. total difficulty = 100                                   | `A0 → A1`                          |
| t₁   | `A2`      | `A1`의 자식. total difficulty = 190                                            | `A0 → A1 → A2`                     |
| t₂   | `B1`      | 제네시스의 또 다른 자식. total difficulty = 120                                | canonical 유지(더 가벼움)          |
| t₃   | `B2`      | `B1`의 자식. total difficulty = 220                                            | `B` 포크가 더 무거워서 reorg 발생. canonical은 `A0 → B1 → B2` |
| t₄   | `A3`      | A 포크가 뒤늦게 도착. total difficulty = 280                                   | canonical은 다시 `A0 → A1 → A2 → A3` |

이벤트 t₃에서 `depth = 2`(A2, A1 롤백), t₄에서는 `depth = 2`(B2, B1 롤백) 같은 신호가 외부 Stage로 전달됩니다. 이 정보만으로도 상위 모듈은 정확한 롤백·재실행 절차를 진행할 수 있습니다.

---

## 9. 테스트 전략: 실패 경로부터 챙겨라

포크 선택기는 다양한 실패 케이스를 견디는 것이 중요합니다.

- **기본 확장 테스트**: 직선형 체인에서 `Extended`가 제대로 나오고 canonical이 업데이트되는지 확인.
- **경쟁 포크 테스트**: 총 난이도가 작은 포크는 무시되는지, 더 무거워지면 reorg로 전환하는지 검증.
- **에러 테스트**: 중복 해시, 잘못된 번호, 미존재 부모가 각각 올바른 에러를 내는지 확인.
- **깊은 reorg 테스트**: 여러 단계 되감기를 요구하는 상황에서 `depth`가 정확한지 검증.

테스트를 작성하면 “올바른 포크 선택기”를 정의한 계약서가 되며, 이후 Stage와 연동해도 안심하고 사용할 수 있습니다.

---

## 10. 더 깊이 파고들고 싶다면?

- **Reth 디자인 문서**: [Header Stage](https://reth.rs/design/stages/headers.html), [Header Accumulator](https://github.com/paradigmxyz/reth/blob/main/crates/stages/src/stages/header/accumulator.rs)
- **Geth Fork Choice 설명**: [https://geth.ethereum.org/docs/fundamentals/consensus](https://geth.ethereum.org/docs/fundamentals/consensus)
- **PoS 이후의 변화 탐구**: Ethereum Merge 이후에는 `total difficulty` 대신 `weight` 개념을 사용하지만, 추적 대상이 바뀌었을 뿐 “가장 무거운 체인 선택”이라는 원리는 여전히 유효합니다.

---

### 오늘의 TIL 요약
- 포크 선택기는 헤더 그래프에서 canonical을 유지하며, 누적 난이도를 비교해 언제든 재구성할 준비가 되어 있어야 한다.
- `StoredHeader`와 `nodes` 맵 덕분에 parent 추적과 누적 난이도 갱신이 빨라지며, `canonical` 벡터는 “현재 공식 체인”을 명확히 표현한다.
- `ReorgOutcome`과 `HeaderInsertError`는 Stage 간 계약을 명시해, 시스템 전체가 안정적으로 동작하도록 돕는다.
