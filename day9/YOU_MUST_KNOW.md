# YOU_MUST_KNOW

- 제네시스는 체인의 절대 기준점이므로 어떤 버퍼든 항상 가장 먼저 적재해야 합니다.
- 헤더는 번호, 해시, 부모 해시, 난이도를 통해 체인을 규정하고, 각 필드를 검증하는 것이 곧 체인 무결성 검사입니다.
- total difficulty는 단순 합계지만 체인 선택의 핵심 지표이므로 정밀한 타입(`u128`)으로 관리합니다.

## 1. 제네시스 블록의 의미
- 블록체인의 시작점이자 네트워크가 공유하는 *하드 코드된* 기준입니다.
- 재시작 시에도 동일한 제네시스를 다시 로드해야 하므로, Reth를 포함한 모든 클라이언트는 제네시스 정보를 명시적으로 저장하거나 설정 파일에서 불러옵니다.
- 우리의 헤더 버퍼도 제네시스를 첫 요소로 삽입해 나머지 검증이 모두 이 지점에서 출발하도록 해야 합니다.

## 2. 블록 헤더가 담는 핵심 정보
- `number`: 체인에서의 위치. 부모보다 항상 1만큼 커야 순차성이 보장됩니다.
- `hash`: 헤더 전체를 해싱한 값. 체인 내 유일한 ID이므로 중복되면 안 됩니다.
- `parent_hash`: 직전 블록의 해시. 체인을 연결하는 링크이며, 존재하지 않으면 포크가 단절됩니다.
- `difficulty`: PoW 시대의 난이도이지만, Reth는 호환성을 위해 여전히 추적합니다. 우리가 total difficulty를 계산할 때 사용됩니다.

## 3. Total Difficulty란?
- 체인의 "투자된 작업량"을 표현하는 누적값입니다. PoW에서는 값이 높은 체인이 가장 정당한 체인으로 선택됩니다.
- 난이도는 `u64` 범위지만 블록 수가 늘어나면 곱절 이상으로 커질 수 있으니 `u128` 같은 더 넓은 타입으로 합산하는 편이 안전합니다.
- PoS 전환 이후에도 terminal total difficulty, finalized checkpoint 등을 계산할 때 이 누적값이 기초 자료로 쓰입니다.

## 4. HashMap을 이용한 빠른 조회
- `HashMap<String, usize>` 형태로 `hash -> canonical index`를 저장하면 평균 O(1)에 해시 존재 여부와 위치를 확인할 수 있습니다.
- Reth의 실제 구현도 DB 인덱스에 비슷한 정보를 저장해 parent hash를 기준으로 빠르게 조회합니다.
- 테스트에서는 `assert_eq!(buffer.index_by_hash.get(parent), Some(&idx))`처럼 인덱스 상태를 직접 확인해 로직을 검증하세요.

## 5. 오류 처리를 통한 방어적 프로그래밍
- 부모 미등록, 번호 불일치, 해시 중복은 각각 다른 복구 전략이 필요하므로 `enum` 변형으로 명확히 구분합니다.
- 이렇게 세분화된 에러는 Stage 상위 계층이 "부모가 비어 있으니 동기화 범위를 넓혀라" 같은 결정을 내릴 때 근거가 됩니다.
- 테스트에서 각 오류 케이스를 분리해 확인하면 실제 Stage 파이프라인에서도 신뢰할 수 있는 방어선을 갖추게 됩니다.
