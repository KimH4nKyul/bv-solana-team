# TIL: SlotPlanner `try_add` 시그니처 점검

## 문제
- 현재 구현은 `SlotPlanner::try_add(&mut self, entry: &MempoolEntry)` 형태로 트랜잭션을 참조로 받아 내부에서 `clone`합니다.
- README 명세와 예제 코드는 `planner.try_add(tx)`처럼 소유권을 넘기는 호출을 가정하고 있어 그대로는 컴파일되지 않습니다.
- 구현과 문서 사이의 불일치가 유지되면 새로운 사용자가 API를 그대로 적용할 때 혼란과 런타임 비용(불필요한 `clone`)이 발생합니다.

## 해결 방안
- `try_add` 시그니처를 `pub fn try_add(&mut self, entry: MempoolEntry) -> bool`로 변경하여 호출 시 값을 이동시키도록 맞춥니다.
- 내부에서는 `self.can_add(&entry)`처럼 참조를 넘겨 제약 검사를 수행하고, 조건을 통과하면 `entry`를 그대로 `push`합니다.
- README 예시 및 테스트 코드(`src/lib.rs`, `tests/planner.rs`)도 값 이동 호출 패턴으로 정리하여 문서-코드 일관성을 확보합니다.
- 부가적으로, 더 이상 필요 없는 `PlannedBundle` 임포트를 제거해 경고를 없앱니다.

## 관련 개념 정리
- **값 이동(move)**  
  - 함수나 변수에 값을 넘기면서 소유권이 새 위치로 이전되면 기존 바인딩은 더 이상 그 값을 사용할 수 없습니다. 예를 들어 `planner.try_add(tx)` 호출 뒤에는 `tx`가 이동(move)되어 `planner`가 소유자가 됩니다. 이동은 보통 스택에 있는 포인터/길이 정보를 그대로 복사하는 얕은 복사이기 때문에 별도의 힙 메모리 할당이 일어나지 않습니다.
  - 이동을 통해 새 소유자가 명확해지므로 데이터가 더 이상 필요 없는 위치에서 해제되거나 중복 해제가 될 위험이 사라집니다.

- **참조 대여(borrow)**  
  - `&entry`나 `&mut entry`처럼 참조를 넘기면 소유권은 호출자에게 남아 있고, 빌리는 쪽은 일시적으로 읽거나(불변 참조) 수정할 수 있습니다(가변 참조). 빌리는 동안의 사용 제약(가변 참조는 단독, 불변 참조는 다중 허용)이 컴파일 단계에서 체크됩니다.
  - SlotPlanner에 트랜잭션을 참조로 넘기면 플래너는 데이터를 소유하지 못하므로 나중에 저장하려면 별도의 복제가 필요합니다. 현재 구현의 `clone`이 바로 그 예입니다.

- **`clone`과 메모리 할당**  
  - `Clone` 구현은 보통 힙에 데이터를 다시 할당하거나 내부 버퍼를 새로 복사해 완전한 복제본을 만듭니다. `MempoolEntry`는 단순한 정수 필드라 할당 비용이 없지만, 구조체가 `Vec`, `String` 같은 힙 데이터를 포함한다면 `clone`은 새로운 힙 메모리를 예약하고 데이터를 모두 복사합니다.
  - 이동은 기존 힙 포인터를 그대로 옮기는 반면, `clone`은 힙에 새 버퍼를 만들고 내용을 복사하기 때문에 CPU와 메모리 사용량이 증가합니다. SlotPlanner가 트랜잭션을 소유해야 할 때는 이동을 통한 소유권 이전이 자연스러우며, 불필요한 `clone`을 제거하면 메모리 할당과 복사 비용을 줄일 수 있습니다.
